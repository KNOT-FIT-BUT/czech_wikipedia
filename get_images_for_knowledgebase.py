#!/usr/bin/env python3
 
#########################################################################################################################################
###
### Scripts reads incomplete knowledgebase, downloads html pages of the articles and extracts image urls.
### Output is the complete knowledgebase with image urls.
### USAGE: get_images_for_kb.py -i incomplete-kb.txt -o kb.txt
### See README.md for instructions on extraction
###
#########################################################################################################################################


import sys
import argparse
import re
import os.path
import html
import logging
import time

import requests



def complete_knowledgebase(input_file:str, output_file:str, logger) -> None:
	### Complete knowledgebase by extracting image URLs
	
	incomplete_knowledgebase_file = open(input_file, "r")
	kb_file = open(output_file, "w")
	pages_retrieved = 0



	for line in incomplete_knowledgebase_file:
		time.sleep(1) # delay between requests, so we dont overload wikipedia servers
		url = line.split('\t')[1]
		kb_line = line[:-1]
		try:
			reqResult = requests.get(url,timeout=10)
			imgList = re.findall(r'<img.*?src="//upload\.wikimedia\.org/(.*?)".*?>', reqResult.text)
			imgList = map(lambda x: re.sub(r'\|', '\|', x), imgList) # not a same - pattern is escaped, replacement is plain text
			kb_line = kb_line + '\t' + '|'.join(set(imgList)) + '\n' # remove duplicities by converting to set
		except:
			logger.error("requests.get() failed to retrieve page at {}. Continuing with next url.".format(url))
			kb_line = kb_line + '\t' + '\n'

		kb_file.write(kb_line) # append the image urls to the knowledgebase and write the complete line to the kb

		# Progress measurement
		pages_retrieved += 1
		if pages_retrieved % 100 == 0:
			logger.info("Processed {} pages.".format(pages_retrieved))

	logger.info("Done. URLs processed: {}.".format(pages_retrieved))

	incomplete_knowledgebase_file.close()
	kb_file.close()


def main(argList:list = None) -> None:
	"""Entry point"""

	"""Can be executed on its own (then it takes arguments from the shell), 
	or can be executed in another script, in which case the script
	can pass custom, modified list of arguments"""

	argParser = argparse.ArgumentParser(description="""Script for completing knowledgebase by downloading html wikipages and
																	extracting image URLs from them.""")

	argParser.add_argument('-i', '--input', help="""Incomplete knowledgebase file generated by czechwiki_extractor.py.""",required=True)
	argParser.add_argument('-o', '--output', help="""Output file - complete knowledgebase.""", required=True)
	argParser.add_argument('-l', '--logfile', help="""Write script info messages and error into logfile (by default written only to stderr).""")
	

### Read arguments from terminal/shell or from the main() method argument list, if it's not empty
	if argList == None:
		args = argParser.parse_args()
	else:
		args = argParser.parse_args(argList)


	# Setup module LOGGER
	logger = logging.getLogger(__file__)
	logger.setLevel(logging.INFO)
	
	# handler to the stderr:
	stderrHandler = logging.StreamHandler(sys.stderr)
	stderrHandler.setFormatter(logging.Formatter('[%(asctime)s]-[%(name)s]-[%(levelname)s]: %(message)s'))
	logger.addHandler(stderrHandler)

	# write also to logfile if the argument was passed:
	if args.logfile:
		logfileHandler = logging.FileHandler(args.logfile)
		logfileHandler.setFormatter(logging.Formatter('[%(asctime)s]-[%(name)s]-[%(levelname)s]: %(message)s'))
		logger.addHandler(logfileHandler)


	logger.info("==== Script started ====")


### Check options validity, create output directory if it does not exist
### For any invalid options, print some error message and then exit.
	
	optionsValid = True
	
	# TODO - validate Options, paths, ...

	if not optionsValid:
		logger.error("==== Script terminating with exit status [1] ====")
		sys.exit(1)
	else: # Perform extraction
		complete_knowledgebase(args.input, args.output, logger)
	logger.info("==== Scrip succesfully finished with exit status [0] ====")
	sys.exit()



if __name__ == '__main__':
	main()
